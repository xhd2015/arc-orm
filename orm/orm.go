// Package orm provides the Object-Relational Mapping functionality
package orm

import (
	"context"
	"errors"
	"fmt"
	"reflect"
	"time"

	"github.com/xhd2015/less-gen/strcase"
	"github.com/xhd2015/ormx/engine"
	"github.com/xhd2015/ormx/field"
	"github.com/xhd2015/ormx/sql"
	"github.com/xhd2015/ormx/table"
)

// ORM provides database operations for any model
// This is typically generated by the ormx code generator
// T represents the model type
// P represents the optional fields type for partial updates
type ORM[T any, P any] struct {
	table  table.Table
	engine engine.Factory
}

// Common errors
var (
	ErrNothingToUpdate   = errors.New("nothing to update")
	ErrMissingIDField    = errors.New("table is missing 'id' field")
	ErrMissingCountField = errors.New("model type must have a Count field of type int64")
)

// New creates a new ORM instance and validates the model and optional fields types
func New[T any, P any](engine engine.Factory, table table.Table) (*ORM[T, P], error) {
	orm := &ORM[T, P]{
		table:  table,
		engine: engine,
	}

	// Validate the model and optional fields types
	if err := orm.Validate(); err != nil {
		return nil, fmt.Errorf("ORM validation failed: %w", err)
	}

	return orm, nil
}

// MustNew creates a new ORM instance and panics if validation fails
func MustNew[T any, P any](engine engine.Factory, table table.Table) *ORM[T, P] {
	orm, err := New[T, P](engine, table)
	if err != nil {
		panic(err)
	}
	return orm
}

// Query executes the provided SQL query and returns matching records
func (o *ORM[T, P]) Query(ctx context.Context, query string, args []interface{}) ([]*T, error) {
	// Create a slice to hold the results
	var results []*T

	// Execute the query using the engine
	err := o.engine.GetEngine().Query(ctx, query, args, &results)
	if err != nil {
		return nil, fmt.Errorf("failed to execute query: %w", err)
	}

	return results, nil
}

// QueryByID retrieves a record by its primary key
func (o *ORM[T, P]) QueryByID(ctx context.Context, id int64) (*T, error) {
	// Build the query string for finding by ID
	// We assume the primary key field is called "id" for simplicity
	// In a real implementation, this could be determined from struct tags or other metadata
	query := fmt.Sprintf("SELECT * FROM %s WHERE id = ? LIMIT 1", o.table.Name())

	// Create a slice to hold the result
	var results []*T

	// Execute the query
	err := o.engine.GetEngine().Query(ctx, query, []interface{}{id}, &results)
	if err != nil {
		return nil, fmt.Errorf("failed to execute QueryByID: %w", err)
	}

	// Check if we found a result
	if len(results) == 0 {
		return nil, nil // Not found, return nil
	}

	return results[0], nil
}

// Insert adds a new record to the database and returns the generated ID
func (o *ORM[T, P]) Insert(ctx context.Context, model *T) (int64, error) {
	// Use reflection to extract field values from the model
	if model == nil {
		return 0, errors.New("model cannot be nil")
	}

	// Get the reflect.Value of the model struct (dereference the pointer)
	v := reflect.ValueOf(model).Elem()
	t := v.Type()

	// Create the SQL Insert builder
	builder := sql.InsertInto(o.table.Name())

	// Map struct fields to table fields
	tableFields := make(map[string]field.Field)
	for _, f := range o.table.Fields() {
		tableFields[f.Name()] = f
	}

	// Iterate through the struct fields and add them to the builder
	for i := 0; i < v.NumField(); i++ {
		field := v.Field(i)
		fieldType := t.Field(i)

		// Skip unexported fields
		if !fieldType.IsExported() {
			continue
		}

		// Skip Count field (if present)
		if fieldType.Name == "Count" {
			continue
		}

		// Convert field name to snake_case
		fieldName := strcase.CamelToSnake(fieldType.Name)

		// Get the corresponding table field
		tableField, exists := tableFields[fieldName]
		if !exists {
			continue // Skip fields not in the table
		}

		// Convert Go value to SQL value based on type
		var sqlValue interface {
			ToExpressionSQL() (string, interface{})
		}
		switch field.Kind() {
		case reflect.String:
			sqlValue = sql.String(field.String())
		case reflect.Int, reflect.Int64:
			sqlValue = sql.Int64(field.Int())
		case reflect.Float64:
			sqlValue = sql.Float64(field.Float())
		case reflect.Bool:
			sqlValue = sql.Bool(field.Bool())
		case reflect.Struct:
			// Handle time.Time specially
			if fieldType.Type.String() == "time.Time" {
				timeValue := field.Interface().(time.Time)

				// Auto-fill CreateTime and UpdateTime with current time if they're zero
				if (fieldType.Name == "CreateTime" || fieldType.Name == "UpdateTime") && timeValue.IsZero() {
					timeValue = time.Now()
				}

				sqlValue = sql.Time(timeValue)
			}
		}

		// Skip if we couldn't convert the value
		if sqlValue == nil {
			continue
		}

		// Add to the builder
		builder.Set(tableField, sqlValue)
	}

	// Generate the SQL and args
	query, args, err := builder.SQL()
	if err != nil {
		return 0, fmt.Errorf("failed to build insert SQL: %w", err)
	}

	// Execute the insert and get the ID
	id, err := o.engine.GetEngine().ExecInsert(ctx, query, args)
	if err != nil {
		return 0, fmt.Errorf("failed to execute Insert: %w", err)
	}

	return id, nil
}

// Count executes a count query and returns the matching records
// The model must have a Count field of type int64 to receive the count value
func (o *ORM[T, P]) Count(ctx context.Context, query string, args []interface{}) ([]*T, error) {
	// TODO: make this validate once when creating the ORM instance
	// Validate that type T has a Count field of type int64
	modelType := reflect.TypeOf((*T)(nil)).Elem()

	// Find the Count field
	countField, found := modelType.FieldByName("Count")
	if !found {
		return nil, ErrMissingCountField
	}

	// Validate the Count field type is int64
	int64Type := reflect.TypeOf(int64(0))
	if countField.Type != int64Type {
		return nil, fmt.Errorf("%w, got %s", ErrMissingCountField, countField.Type.String())
	}

	// Execute the query using the Query method
	return o.Query(ctx, query, args)
}

// UpdateByID updates an existing record by ID with partial fields
func (o *ORM[T, P]) UpdateByID(ctx context.Context, id int64, data *P) error {
	if id == 0 {
		return fmt.Errorf("requires id, got 0")
	}
	if data == nil {
		return fmt.Errorf("requires data, got nil")
	}

	// Validate that the table has an 'id' field
	hasIDField := false
	for _, f := range o.table.Fields() {
		if f.Name() == "id" {
			hasIDField = true
			break
		}
	}
	if !hasIDField {
		return ErrMissingIDField
	}

	// Create the SQL Update builder
	builder := sql.Update(o.table.Name())

	// Map struct fields to table fields
	tableFields := make(map[string]field.Field)
	for _, f := range o.table.Fields() {
		tableFields[f.Name()] = f
	}

	// Flag to track if we have any fields to update
	hasFieldsToUpdate := false

	// Check if the model has an UpdateTime field and if it's nil
	shouldAddUpdateTime := false
	hasUpdateTimeField := false
	var updateTimeField field.Field

	// Use reflection to extract non-nil fields from the partialModel
	v := reflect.ValueOf(data).Elem()
	t := v.Type()

	// Iterate through the struct fields and add them to the builder
	for i := 0; i < v.NumField(); i++ {
		field := v.Field(i)
		fieldType := t.Field(i)

		// Skip unexported fields
		if !fieldType.IsExported() {
			continue
		}

		// Special handling for UpdateTime
		if fieldType.Name == "UpdateTime" {
			hasUpdateTimeField = true
			fieldName := strcase.CamelToSnake(fieldType.Name)
			updateTimeField = tableFields[fieldName]

			// If the field is nil, we should add update_time to the query
			if field.Kind() == reflect.Ptr && field.IsNil() {
				shouldAddUpdateTime = true
			}
		}

		// Get the field value
		var fieldRValue reflect.Value
		if field.Kind() == reflect.Ptr {
			if field.IsNil() {
				// Skip nil pointer fields
				continue
			}
			fieldRValue = field.Elem()
		} else {
			fieldRValue = field
		}
		fieldValue := fieldRValue.Interface()

		// Convert field name to snake_case
		fieldName := strcase.CamelToSnake(fieldType.Name)

		// Get the corresponding table field
		tableField, exists := tableFields[fieldName]
		if !exists {
			continue // Skip fields not in the table
		}

		// Convert Go value to SQL value based on type
		var sqlValue interface {
			ToExpressionSQL() (string, interface{})
		}

		switch fieldRValue.Kind() {
		case reflect.String:
			sqlValue = sql.String(fieldValue.(string))
		case reflect.Int, reflect.Int64:
			if i64, ok := fieldValue.(int64); ok {
				sqlValue = sql.Int64(i64)
			} else if i, ok := fieldValue.(int); ok {
				sqlValue = sql.Int64(int64(i))
			}
		case reflect.Float64:
			sqlValue = sql.Float64(fieldValue.(float64))
		case reflect.Bool:
			sqlValue = sql.Bool(fieldValue.(bool))
		case reflect.Struct:
			// Handle time.Time specially
			if t, ok := fieldValue.(time.Time); ok {
				sqlValue = sql.Time(t)
			}
		}

		// Skip if we couldn't convert the value
		if sqlValue == nil {
			continue
		}

		// Add to the builder
		builder.Set(tableField, sqlValue)
		hasFieldsToUpdate = true
	}

	// Check if there are any fields to update
	if !hasFieldsToUpdate {
		return ErrNothingToUpdate
	}

	// If we have an UpdateTime field that was nil, add it to the query with current time
	if hasUpdateTimeField && shouldAddUpdateTime {
		builder.Set(updateTimeField, sql.Time(time.Now()))
	}

	// Create a field specifically for the ID condition
	// Use an Int64Field with empty TableName so it outputs just `id`
	idField := field.Int64Field{
		FieldName: "id",
		// TableName is intentionally left empty to get just `id` rather than `table`.`id`
	}

	// Add WHERE clause for ID
	builder.Where(idField.Eq(id))

	// Generate the SQL and args
	query, args, err := builder.SQL()
	if err != nil {
		return fmt.Errorf("failed to build update SQL: %w", err)
	}

	// Execute the update
	err = o.engine.GetEngine().Exec(ctx, query, args)
	if err != nil {
		return fmt.Errorf("failed to execute UpdateByID: %w", err)
	}

	return nil
}

// DeleteByID deletes a record by its ID
func (o *ORM[T, P]) DeleteByID(ctx context.Context, id int64) error {
	if id == 0 {
		return fmt.Errorf("requires id, got 0")
	}

	// Validate that the table has an 'id' field
	hasIDField := false
	for _, f := range o.table.Fields() {
		if f.Name() == "id" {
			hasIDField = true
			break
		}
	}
	if !hasIDField {
		return ErrMissingIDField
	}

	// Create a field specifically for the ID condition
	// Use an Int64Field with empty TableName so it outputs just `id`
	idField := field.Int64Field{
		FieldName: "id",
	}

	// Create the SQL Delete builder
	query, args, err := sql.DeleteFrom(o.table.Name()).
		Where(idField.Eq(id)).
		SQL()

	if err != nil {
		return fmt.Errorf("sql: %w", err)
	}

	// Execute the delete
	err = o.engine.GetEngine().Exec(ctx, query, args)
	if err != nil {
		return fmt.Errorf("failed to execute DeleteByID: %w", err)
	}

	return nil
}
