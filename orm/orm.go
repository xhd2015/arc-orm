// Package orm provides the Object-Relational Mapping functionality
package orm

import (
	"context"
	"errors"
	"fmt"
	"reflect"
	"time"

	"github.com/xhd2015/arc-orm/engine"
	"github.com/xhd2015/arc-orm/field"
	"github.com/xhd2015/arc-orm/sql"
	"github.com/xhd2015/arc-orm/table"
	"github.com/xhd2015/less-gen/strcase"
)

// ORM provides database operations for any model
// This is typically generated by the ormx code generator
// T represents the model type
// P represents the optional fields type for partial updates
type ORM[T any, P any] struct {
	table  table.Table
	engine engine.Factory
}

// Common errors
var (
	ErrNothingToUpdate   = errors.New("nothing to update")
	ErrMissingIDField    = errors.New("table is missing 'id' field")
	ErrMissingCountField = errors.New("model type must have a Count field of type int64")
)

// Bind creates a new ORM instance and panics if validation fails
func Bind[T any, P any](engine engine.Factory, table table.Table) *ORM[T, P] {
	orm, err := bind[T, P](engine, table)
	if err != nil {
		panic(err)
	}
	return orm
}

// bind creates a new ORM instance and validates the model and optional fields types
func bind[T any, P any](engine engine.Factory, table table.Table) (*ORM[T, P], error) {
	orm := &ORM[T, P]{
		table:  table,
		engine: engine,
	}

	// Validate the model and optional fields types
	if err := orm.Validate(); err != nil {
		return nil, fmt.Errorf("ORM validation failed: %w", err)
	}

	return orm, nil
}

// Query executes the provided SQL query and returns matching records
func (o *ORM[T, P]) Query(ctx context.Context, query string, args []interface{}) ([]*T, error) {
	// Create a slice to hold the results
	var results []*T

	// Execute the query using the engine
	err := o.engine.GetEngine().Query(ctx, query, args, &results)
	if err != nil {
		return nil, fmt.Errorf("failed to execute query: %w", err)
	}

	return results, nil
}

// GetByID retrieves a record by its primary key
// the record must exist, otherwise it will return an error
func (o *ORM[T, P]) GetByID(ctx context.Context, id int64) (*T, error) {
	// check id is valid
	if id == 0 {
		return nil, fmt.Errorf("id is 0")
	}

	// check table has id field
	var idField field.Field
	for _, f := range o.table.Fields() {
		if f.Name() == "id" {
			idField = f
			break
		}
	}
	if idField == nil {
		return nil, fmt.Errorf("table %s is missing 'id' field", o.table.Name())
	}
	idFieldInt64, ok := idField.(field.Int64Field)
	if !ok {
		return nil, fmt.Errorf("id field is not an int64 field")
	}

	querySQL, args, err := sql.Select(o.table.Fields()...).
		From(o.table.Name()).
		Where(idFieldInt64.Eq(id)).
		Limit(1).
		SQL()
	if err != nil {
		return nil, fmt.Errorf("sql: %w", err)
	}

	// Create a slice to hold the result
	var results []*T

	// Execute the query
	err = o.engine.GetEngine().Query(ctx, querySQL, args, &results)
	if err != nil {
		return nil, fmt.Errorf("failed to execute Get: %w", err)
	}

	// Check if we found a result
	if len(results) == 0 {
		return nil, fmt.Errorf("%s not found with: id=%d", o.table.Name(), id)
	}

	return results[0], nil
}

// Insert adds a new record to the database and returns the generated ID
func (o *ORM[T, P]) Insert(ctx context.Context, model *T) (int64, error) {
	// Use reflection to extract field values from the model
	if model == nil {
		return 0, errors.New("model cannot be nil")
	}

	// Get the reflect.Value of the model struct (dereference the pointer)
	v := reflect.ValueOf(model).Elem()
	t := v.Type()

	// Create the SQL Insert builder
	builder := sql.InsertInto(o.table.Name())

	// Map struct fields to table fields
	tableFields := make(map[string]field.Field)
	for _, f := range o.table.Fields() {
		tableFields[f.Name()] = f
	}

	// Iterate through the struct fields and add them to the builder
	for i := 0; i < v.NumField(); i++ {
		field := v.Field(i)
		fieldType := t.Field(i)

		// Skip unexported fields
		if !fieldType.IsExported() {
			continue
		}

		// Skip Count field (if present)
		if fieldType.Name == "Count" {
			continue
		}

		// Convert field name to snake_case
		fieldName := strcase.CamelToSnake(fieldType.Name)

		// Get the corresponding table field
		tableField, exists := tableFields[fieldName]
		if !exists {
			continue // Skip fields not in the table
		}

		// Convert Go value to SQL value based on type
		var sqlValue interface {
			ToExpressionSQL() (string, interface{})
		}
		switch field.Kind() {
		case reflect.String:
			sqlValue = sql.String(field.String())
		case reflect.Int, reflect.Int64:
			sqlValue = sql.Int64(field.Int())
		case reflect.Float64:
			sqlValue = sql.Float64(field.Float())
		case reflect.Bool:
			sqlValue = sql.Bool(field.Bool())
		case reflect.Struct:
			// Handle time.Time specially
			if fieldType.Type.String() == "time.Time" {
				timeValue := field.Interface().(time.Time)

				// Auto-fill CreateTime and UpdateTime with current time if they're zero
				if (fieldType.Name == "CreateTime" || fieldType.Name == "UpdateTime") && timeValue.IsZero() {
					timeValue = time.Now()
				}

				sqlValue = sql.Time(timeValue)
			}
		}

		// Skip if we couldn't convert the value
		if sqlValue == nil {
			continue
		}

		// Add to the builder
		builder.Set(tableField, sqlValue)
	}

	// Generate the SQL and args
	query, args, err := builder.SQL()
	if err != nil {
		return 0, fmt.Errorf("failed to build insert SQL: %w", err)
	}

	// Execute the insert and get the ID
	id, err := o.engine.GetEngine().ExecInsert(ctx, query, args)
	if err != nil {
		return 0, fmt.Errorf("failed to execute Insert: %w", err)
	}

	return id, nil
}

// Count executes a count query and returns the matching records
// The model must have a Count field of type int64 to receive the count value
func (o *ORM[T, P]) Count(ctx context.Context, query string, args []interface{}) ([]*T, error) {
	// TODO: make this validate once when creating the ORM instance
	// Validate that type T has a Count field of type int64
	modelType := reflect.TypeOf((*T)(nil)).Elem()

	// Find the Count field
	countField, found := modelType.FieldByName("Count")
	if !found {
		return nil, ErrMissingCountField
	}

	// Validate the Count field type is int64
	int64Type := reflect.TypeOf(int64(0))
	if countField.Type != int64Type {
		return nil, fmt.Errorf("%w, got %s", ErrMissingCountField, countField.Type.String())
	}

	// Execute the query using the Query method
	return o.Query(ctx, query, args)
}

// UpdateByID updates an existing record by ID with partial fields
func (o *ORM[T, P]) UpdateByID(ctx context.Context, id int64, data *P) error {
	idCondition, err := o.toIDCondition(id)
	if err != nil {
		return fmt.Errorf("failed to convert id to condition: %w", err)
	}

	return o.update(ctx, []field.Condition{idCondition}, data)
}

func (o *ORM[T, P]) UpdateBy(ctx context.Context, condition *P, data *P) error {
	if condition == nil {
		return fmt.Errorf("requires condition")
	}

	sqlConditions, err := o.ToConditions(condition)
	if err != nil {
		return fmt.Errorf("failed to convert condition to SQL conditions: %w", err)
	}

	return o.update(ctx, sqlConditions, data)
}

func (o *ORM[T, P]) update(ctx context.Context, conditions []field.Condition, data *P) error {
	if data == nil {
		return fmt.Errorf("requires data, got nil")
	}
	if len(conditions) == 0 {
		return fmt.Errorf("requires conditions")
	}

	// Create the SQL Update builder
	builder := sql.Update(o.table.Name())

	// Map struct fields to table fields
	tableFields := make(map[string]field.Field)
	for _, f := range o.table.Fields() {
		tableFields[f.Name()] = f
	}

	// Flag to track if we have any fields to update
	hasFieldsToUpdate := false

	// Check if the model has an UpdateTime field and if it's nil
	shouldAddUpdateTime := false
	hasUpdateTimeField := false
	var updateTimeField field.Field

	// Use reflection to extract non-nil fields from the partialModel
	v := reflect.ValueOf(data).Elem()
	t := v.Type()

	// Iterate through the struct fields and add them to the builder
	for i := 0; i < v.NumField(); i++ {
		field := v.Field(i)
		fieldType := t.Field(i)

		// Skip unexported fields
		if !fieldType.IsExported() {
			continue
		}

		// Special handling for UpdateTime
		if fieldType.Name == "UpdateTime" {
			hasUpdateTimeField = true
			fieldName := strcase.CamelToSnake(fieldType.Name)
			updateTimeField = tableFields[fieldName]

			// If the field is nil, we should add update_time to the query
			if field.Kind() == reflect.Ptr && field.IsNil() {
				shouldAddUpdateTime = true
			}
		}

		// Get the field value
		var fieldRValue reflect.Value
		if field.Kind() == reflect.Ptr {
			if field.IsNil() {
				// Skip nil pointer fields
				continue
			}
			fieldRValue = field.Elem()
		} else {
			fieldRValue = field
		}
		fieldValue := fieldRValue.Interface()

		// Convert field name to snake_case
		fieldName := strcase.CamelToSnake(fieldType.Name)

		// Get the corresponding table field
		tableField, exists := tableFields[fieldName]
		if !exists {
			continue // Skip fields not in the table
		}

		// Convert Go value to SQL value based on type
		var sqlValue interface {
			ToExpressionSQL() (string, interface{})
		}

		switch fieldRValue.Kind() {
		case reflect.String:
			sqlValue = sql.String(fieldRValue.String())
		case reflect.Int, reflect.Int64:
			sqlValue = sql.Int64(fieldRValue.Int())
		case reflect.Int32:
			sqlValue = sql.Int32(fieldRValue.Int())
		case reflect.Float64:
			sqlValue = sql.Float64(fieldRValue.Float())
		case reflect.Bool:
			sqlValue = sql.Bool(fieldRValue.Bool())
		case reflect.Struct:
			// Handle time.Time specially
			if t, ok := fieldValue.(time.Time); ok {
				sqlValue = sql.Time(t)
			}
		}

		// Skip if we couldn't convert the value
		if sqlValue == nil {
			continue
		}

		// Add to the builder
		builder.Set(tableField, sqlValue)
		hasFieldsToUpdate = true
	}

	// Check if there are any fields to update
	if !hasFieldsToUpdate {
		return ErrNothingToUpdate
	}

	// If we have an UpdateTime field that was nil, add it to the query with current time
	if hasUpdateTimeField && shouldAddUpdateTime {
		builder.Set(updateTimeField, sql.Time(time.Now()))
	}

	// Add WHERE clause for ID
	builder.Where(conditions...)

	// Generate the SQL and args
	query, args, err := builder.SQL()
	if err != nil {
		return fmt.Errorf("failed to build update SQL: %w", err)
	}

	// Execute the update
	err = o.engine.GetEngine().Exec(ctx, query, args)
	if err != nil {
		return fmt.Errorf("failed to execute UpdateByID: %w", err)
	}

	return nil
}

// DeleteByID deletes a record by its ID
func (o *ORM[T, P]) DeleteByID(ctx context.Context, id int64) error {
	idCondition, err := o.toIDCondition(id)
	if err != nil {
		return fmt.Errorf("failed to convert id to condition: %w", err)
	}

	return o.deleteBy(ctx, []field.Condition{idCondition})
}

// DeleteByID deletes a record by its ID
func (o *ORM[T, P]) DeleteBy(ctx context.Context, condition *P) error {
	if condition == nil {
		return fmt.Errorf("requires condition")
	}

	sqlConditions, err := o.ToConditions(condition)
	if err != nil {
		return fmt.Errorf("failed to convert condition to SQL conditions: %w", err)
	}

	return o.deleteBy(ctx, sqlConditions)
}

func (o *ORM[T, P]) deleteBy(ctx context.Context, conditions []field.Condition) error {
	if len(conditions) == 0 {
		return fmt.Errorf("requires conditions")
	}

	// Create the SQL Delete builder
	query, args, err := sql.DeleteFrom(o.table.Name()).
		Where(conditions...).
		SQL()

	if err != nil {
		return fmt.Errorf("sql: %w", err)
	}

	// Execute the delete
	err = o.engine.GetEngine().Exec(ctx, query, args)
	if err != nil {
		return fmt.Errorf("failed to execute DeleteByID: %w", err)
	}

	return nil
}
